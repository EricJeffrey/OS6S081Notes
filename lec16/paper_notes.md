
Journaling the Linux ext2fs Filesystem

- 尝试解决Linux系统中，文件系统的恢复过程太长的问题
- 目标
  - 性能Performance
  - 兼容性Compatibility
  - 可靠性Reliability
- 崩溃恢复过程，文件系统可靠性Reliability需要针对的问题
  - 保留Preservation - 崩溃前在磁盘上的崩溃后也应在磁盘上
  - 可预测Predictability - 崩溃的模式必须是可预见的，从而有针对性进行可靠恢复
  - 原子性Atomicity - 恢复完成后，文件系统操作的完成情况应当是原子的
- 现有的实现
  - Synchronous Metadata Update，前一个操作完成后才执行第二个
    - 无法batch up多个IO操作
    - workaround1 Defered Ordered Write：在内存中维护一个**有序的**磁盘buffer的；但是面临循环引用问题
    - workaround2 Soft Updates：如果一个缓冲区有外部依赖，就将已经执行的更新回滚
  - 问题：恢复过程仍然需要扫描整个磁盘
- 恢复过程可以更快
  - 事务模式：对磁盘的更新当且仅当在commit后才起作用
- 实现方式
  - WAFL文件系统：维护一个树
  - 基于log的文件系统：将磁盘的写操作保存到连续的log区
    - 优势：块，多个写总是连续的的
    - 实现：Sprite LF3，Berkeley LF4
    - journaling 也称之为 log enhanced 的文件系统
- 事务剖析
  - 一个事务需要包含多个操作的所有更改，包括元数据如inode的时间戳、文件长度、引用信息，剩余磁盘空间大小等
  - 事务需要注意文件系统的读/写操作的order关系
    - `写+（读然后写）`的两个操作具有依赖关系
  - 以及超越元数据更新之间排序要求的
    - 对文件分配新的块前，必须确保所有新创建的block都被写到磁盘上。否则，恢复过程可能会出现新文件包含旧文件数据的问题
- 合并事务
  - 文件系统的事务不同于数据库的事务
    - 没有放弃事务abort操作
    - 生存周期相对较短short-lived：事务不会包含太多的长期依赖，因此可以在不损失性能的情况下，对事务之间的次序进行限制
  - 每隔一段时间创建一个**复合事务 compound transaction**
    - 所有文件系统操作**都使用这个新创建的事务**
  - 事务的提交时间和创建间隔是一种权衡trade-off
    - 长期的事务内存更大，丢失的更新更多
- On-disk representation：兼容现有的ext2
- 文件系统日志的格式
  - Metadata区域：元数据包含每个要更新块的**所有元数据**
    - 很小的更新也会保存所有数据
    - 原因：连续的写入并不会影响性能，避免了额外的CPU工作
  - Descriptor区域：描述Metadata区域
    - 记录其它metadata在磁盘上的块编号
  - Header区域：许多header块，保存日志的首尾
- journal的提交/检查点步骤
  - 关闭事务，未完成的操作仍然存在
    - 一个文件系统的操作不能分割到多个事务
  - 将事务的内容写到磁盘
  - 等待当前事务的所有外部操作完成
  - 等待所有外部更新记录到日志中
  - 更新日志header区域
  - 内存buffer与journal
    - 事务的内存buffer更新到journal中时，该buffer会被pin到内存中
    - 只有在事务对应的journal数据被同步到磁盘的目标区域后（非日志块），journal才能重用
- 事务之间的冲突
  - 一个事务提交的时候，创建一个新的事务避免其它操作等待
  - 潜在冲突：新操作依赖正在提交的事务中的数据更新
    - 只读OK，数据还在内存的buffer中
    - 更新/写要提交的buffer，创建一个拷贝让新事务使用，并在新事务提交后删除
- 总结
  - 日志最大的影响：新创建的文件必须提前同步到磁盘上以便后续提交，无法使用延迟提交
    - 因此`/tmp`等文件系统可能不适合
